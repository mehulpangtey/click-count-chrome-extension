{
  "_args": [
    [
      {
        "raw": "react-chrome-redux@0.0.7",
        "scope": null,
        "escapedName": "react-chrome-redux",
        "name": "react-chrome-redux",
        "rawSpec": "0.0.7",
        "spec": "0.0.7",
        "type": "version"
      },
      "/Users/mehul/Documents/side_project/chrome/goguardian/react-chrome-redux-examples/clicker-key"
    ]
  ],
  "_from": "react-chrome-redux@0.0.7",
  "_id": "react-chrome-redux@0.0.7",
  "_inCache": true,
  "_location": "/react-chrome-redux",
  "_nodeVersion": "4.2.1",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/react-chrome-redux-0.0.7.tgz_1459007942143_0.8317546921316534"
  },
  "_npmUser": {
    "name": "tshaddix",
    "email": "tylershaddix@gmail.com"
  },
  "_npmVersion": "3.4.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "react-chrome-redux@0.0.7",
    "scope": null,
    "escapedName": "react-chrome-redux",
    "name": "react-chrome-redux",
    "rawSpec": "0.0.7",
    "spec": "0.0.7",
    "type": "version"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/react-chrome-redux/-/react-chrome-redux-0.0.7.tgz",
  "_shasum": "73a7e96416ae3ccdaaf488f902f5cdd3a7d54dfa",
  "_shrinkwrap": null,
  "_spec": "react-chrome-redux@0.0.7",
  "_where": "/Users/mehul/Documents/side_project/chrome/goguardian/react-chrome-redux-examples/clicker-key",
  "author": {
    "name": "Tyler Shaddix"
  },
  "bugs": {
    "url": "https://github.com/tshaddix/react-chrome-redux/issues"
  },
  "dependencies": {
    "lodash": "^4.5.1"
  },
  "description": "A set of utilities for building React+Redux applications in Google Chrome Extensions.",
  "devDependencies": {
    "babel": "^6.3.26",
    "babel-cli": "^6.4.5",
    "babel-preset-es2015": "^6.3.13",
    "mocha": "^2.3.4",
    "should": "^8.2.0",
    "sinon": "^1.17.2"
  },
  "directories": {},
  "dist": {
    "shasum": "73a7e96416ae3ccdaaf488f902f5cdd3a7d54dfa",
    "tarball": "https://registry.npmjs.org/react-chrome-redux/-/react-chrome-redux-0.0.7.tgz"
  },
  "gitHead": "d456e5c03d4b1125309400c871b9808c5a3e8b5e",
  "homepage": "https://github.com/tshaddix/react-chrome-redux#readme",
  "license": "MIT",
  "main": "lib/index.js",
  "maintainers": [
    {
      "name": "tshaddix",
      "email": "tylershaddix@gmail.com"
    }
  ],
  "name": "react-chrome-redux",
  "optionalDependencies": {},
  "readme": "# react-chrome-redux\nA set of utilities for building React+Redux applications in Google Chrome extensions.\n\n## The Basics\n\nIf you're currently working on a Chrome Extension, or have worked on one in the past, you know that things can get tricky when an extension goes from basic UI or background logic to application level logic. Things you normally breeze through in a \"normal\" web app are suddenly a headache, such as passing data between popovers and background pages.\n\nA Chrome extension has a long lasting page that runs in the background for the lifetime of the extension, and then separate instances of UI pieces such as a popover. Every time a UI piece is triggered, it reloads from scratch, making data management particularly painful when working outside the background page.\n\nThe purpose of this package is to build on the awesome packages of React and Redux, and provide very simple interfaces which allow you to *almost* treat your extension code like your browser code.\n\n## How it Works\n\nThe basic idea is to have the state store (aka Redux) run in the background of the application, and have the React side of the application run in the UI components, such as a Popover.\n\nUsing [Chrome Extension Messaging](https://developer.chrome.com/extensions/messaging), `react-chrome-redux` transfers actions from the UI components to the background store, and state transitions from the background store to the UI components. Check out the simple examples below.\n\n## Basic Example\n\n```js\n// popover.js\n\nimport React from 'react';\nimport {render} from 'react-dom';\nimport {Provider} from 'react-redux';\nimport {Store} from 'react-chrome-redux';\n\nimport App from './components/app/App';\n\nconst store = new Store({\n  portName: 'MY_APP' // communication port name\n});\n\n// The store implements the same interface as Redux's store\n// so you can use tools like `react-redux` no problem!\nrender(\n  <Provider store={store}>\n    <App/>\n  </Provider>\n  , document.getElementById('app'));\n\n```\n\n```js\n// background.js\n\nimport {wrapStore} from 'react-chrome-redux';\n\nconst store; // a normal Redux store\n\nwrapStore(store, {portName: 'MY_APP'}); // make sure portName matches\n```\n\nThat's actually it. The `dispatch`es called from UI component will find their way to the background page no problem. The new state from your background page will make sure to find its way back to the UI components just like all your other apps.\n\n## Async and Complex Actions\n\nBecause actions are sent to the background page via messages in a channel, you don't have the same easy ability to do async behaviour in the initial action call. Don't worry, there's an answer for that: `alias`.\n\n`alias` is a simple middleware which can map actions to new actions. For example, let's say you want to get the current session in your UI components:\n\n```js\n// popover/App.jsx\n\nimport React, {Component} from 'react';\nimport {connect} from 'react-redux';\n\n// the mock action\nconst getSession = () => {\n  const data = {\n    type: ACTION_GET_SESSION,\n    payload: {}\n  };\n\n  return data;\n};\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n  }\n\n  componentDidMount() {\n    this.props.dispatch(getSession());\n  }\n\n  render() {\n    return (\n      <div>\n        {this.props.session && this.props.users[this.props.session.userId].name}\n      </div>\n    );\n  }\n}\n\nconst mapStateToProps = (state) => {\n  return {\n    session: state.session,\n    users: state.users\n  };\n};\n\nexport default connect(mapStateToProps)(App);\n\n```\n\nIn `background.js`, we would get an action of `{type: GET_SESSION}`, which is not very useful to our reducers considering we don't have any data yet.\n\nUsing an alias, we can turn this into a new action that does the desired behaviour:\n\n```js\n// aliases.js\n\nconst getSession = (orginalAction) => {\n  // do async stuff before dispatching, etc\n};\n\nexport default {\n  'GET_SESSION': getSession // the action to proxy and the new action to call\n};\n```\n\nThen you just include it in your middleware for Redux:\n\n```js\nimport {alias} from 'react-chrome-redux';\n\nimport aliases from '../aliases';\n\nconst middleware = [\n  alias(aliases),\n  // whatever middleware you want (like redux-thunk)\n];\n\n// createStoreWithMiddleware... you know the drill\n\n```\n\nThe nice thing about having this as a middleware is that you can run it with other packages such as `react-thunk`. Your alias can return a function to run instead of an action object, and everything will proceed as normal.\n\n## Action Responses in UI components\n\nIt's a common practice to have Redux dispatches return promises with something like `redux-thunk`. This package provides a way to simulate this behavior by providing a `dispatchResponder` in the store wrapper for the background page.\n\nWhen an action is dispatched from a UI Component, it will return a promise that will resolve/reject with a response from the background page:\n\n```js\n// the mock action\nconst getSession = () => {\n  const data = {\n    type: ACTION_GET_SESSION,\n    payload: {}\n  };\n\n  return data;\n};\n\nclass App extends Component {\n  constructor(props) {}\n\n  componentDidMount() {\n    // promise returned from `dispatch()`\n    this.props.dispatch(getSession())\n      .then((data) => {\n        // the response data\n      })\n      .catch((err) => {\n        // something broke in the background store\n      });\n  }\n\n  render() {}\n}\n```\n\nAs you can quickly tell, this is really nice for making UI updates for error/success messages or pending states. By default, this is done by calling a simple `Promise.resolve()` on the dispatch result in the background and responding with an object of `{error, value}` based on rejection or resolution.\n\nWhat if you don't return promises from your dispatches? Or what if those promises are hidden away in somewhere in the payload? You can pass in a `dispatchResponder` to your store wrapper when calling `wrapStore` to take care of that:\n\n```js\n// redux-promise-middleware returns promises under `promise` field in the payload\n\n/**\n * Respond to action based on `redux-promise-middleware` result\n * @param  {object} dispatchResult The resulting object from `store.dispatch()`\n * @param  {func}   send           func to be called when sending response. Should be in form {value, error}\n */\nconst reduxPromiseResponder = (dispatchResult, send) => {\n  Promise\n    .resolve(dispatchResult.payload.promise) // pull out the promise\n    .then((res) => {\n      // if success then respond with value\n      send({\n        error: null,\n        value: res\n      });\n    })\n    .catch((err) => {\n      // if error then respond with error\n      send({\n        error: err,\n        value: null\n      });\n    });\n};\n\n// ...\n\n// Add responder to store\nwrapStore(store, {\n  portName: 'MY_APP',\n  dispatchResponder: reduxPromiseResponder\n});\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/tshaddix/react-chrome-redux.git"
  },
  "scripts": {
    "prepublish": "babel src --out-dir lib",
    "pretest": "babel src --out-dir lib",
    "test": "mocha"
  },
  "version": "0.0.7"
}
